# 第2章 ES6基础

## 2.1 对象字面量

### 2.1.1 属性值简写

### 2.1.2 可计算属性名

### 2.1.3 方法定义

## 2.2 箭头函数

虽然箭头函数看起来和常规的匿名函数很相似，但它们本质上完全不同：

- 箭头函数不能显示地命名，尽管现代运行环境会将箭头函数所赋予的变量名作为函数名；
- 箭头函数不能用作构造函数，也没有 `prototype` 属性，这意味着不能对它们使用 `new` 关键字；
- 箭头函数会绑定到所在词法作用域中，因此它们不会改变 `this` 的指向。

### 2.2.1 词法作用域

!> 由于箭头函数不会创建新的作用域，在箭头函数的函数体内，`this`、`arguments` 以及 `super` 均属于所在的父级作用域。

ES6箭头函数的作用域绑定也意味着使用 `.call`、`.apply`、`.bind` 等方法调用函数时也无法改变 `this` 的指向。这一限制通常是很有用的，确保了上下文不会被修改。

### 2.2.2 箭头函数的写法

### 2.2.3 优点和用例

## 2.3 解构

### 2.3.1 对象的解构

### 2.3.2 数组的解构

### 2.3.3 函数参数的默认值

### 2.3.4 函数参数的解构

### 2.3.5 解构的用例

## 2.4 剩余参数和扩展运算符

### 2.4.1 剩余参数

### 2.4.2 扩展运算符

## 2.5 模版字面量

### 2.5.1 字符串插值

### 2.5.2 多行模版字面量

### 2.5.3 标签模版

## 2.6 let和const声明

### 2.6.1 块级作用域和let声明

### 2.6.2 暂时性死区

在函数声明中访问暂时性死区中的变量是没问题的，只要访问处于暂时性死区中变量的语句在 `let` 声明语句之后执行即可。

> 提升仍然适用于 `let`，即变量在作用域的开始就会创建，但会产生暂时性死区，这些变量在声明语句没有执行前无法访问，离开暂时性死区之后才能够访问。

### 2.6.3 const声明

### 2.6.4 const和let的优势



