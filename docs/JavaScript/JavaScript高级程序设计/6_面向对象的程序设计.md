# 第6章 面向对象的程序设计

**面向对象（Object-Oriented, OO）**的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。

?> 每个对象都是基于一个**引用类型**创建的，这个引用类型可以是第5章讨论的原生类型，也可以是开发人员定义的类型。

## 6.1 理解对象

### 6.1.1 属性类型

ECMA-262第5版在定义只有内部才用的特性（attribute）时，描述了属性（property）的各种特征。ECMA-262定义这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对方括号中，例如 `[[Enumerable]]`。

ECMAScript中有两种属性：数据属性和访问器属性。

#### 1. 数据属性

#### 2. 访问器属性

## 6.2 创建对象

### 6.2.1 工厂模式

<details>
<summary>Ciel按：</summary>

小小的参考：[工厂模式](/设计模式/HeadFirst设计模式/4_工厂模式.md)
</details>



### 6.2.2 构造函数模式

#### 1. 将构造函数当作函数

?> 构造函数与其他函数的唯一区别，就在于调用他们的方式不同。

任何函数，只要通过 `new` 操作符来调用，那它就可以作为构造函数。

#### 2. 构造函数的问题

使用构造函数的问题，就是每个方法都要在每个实例上重新创建一遍。

然而，创建两个完成同样任务的 `Function` 实例的确没有必要；况且有 `this` 对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此，可以通过把函数定义转移到构造函数外部来解决这个问题。

这样做确实解决了两个函数做同一件事的问题，可是新问题又来了：

在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。

而更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。

好在，这些问题可以通过使用原型模式来解决。

### 6.2.3 原型模式

我们创建的每个函数都有一个 `prototype` （原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是**包含可以由特定类型的所有实例共享的属性和方法**。如果按照字面意思来理解，那么 `prototype` 就是通过调用构造函数而创建的那个对象实例的原型对象。

使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。

#### 1. 理解原型对象

?> 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该**函数**创建一个 `prototype` 属性，这个**属性指向函数的原型对象**。

?> 在默认情况下，所有**原型对象**都会自动获得一个 `constructor` （构造函数）属性，这个属性是一个**指向 `prototype` 属性所在函数**的指针。

?> 当调用构造函数创建一个新实例后，该**实例**的内部将包含一个指针（内部属性），**指向构造函数的原型对象**。ECMA-262第5版官这个指针叫 `[[Prototype]]`。

#### 2. 原型与 `in` 操作符

#### 3. 更简单的原型语法

#### 4. 原型的动态性

#### 5. 原生对象的原型

#### 6. 原型对象的问题

### 6.2.4 组合使用构造函数模式和原型模式

### 6.2.5 动态原型模式

### 6.2.6 寄生构造函数模式

### 6.2.7 稳妥构造函数模式

## 6.3 继承

许多OO语言都支持两种继承方式：**接口继承**和**实现继承**。

- **接口继承**只继承方法签名

- 而**实现继承**则继承实际的方法

如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持**实现继承**，而且其实现继承主要是依靠原型链来实现的。

### 6.3.1 原型链

### 6.3.2 借用构造函数

### 6.3.3 组合继承

### 6.3.4 原型式继承

### 6.3.5 寄生式继承

### 6.3.6 寄生组合式继承

