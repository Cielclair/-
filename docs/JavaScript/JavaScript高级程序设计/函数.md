# 函数

## 理解ECMAScript函数的参数

?> ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。

在函数体内可以通过 `arguments` 对象来访问这个参数数组，从而获取传递给函数的每一个参数。

- `arguments` 对象可以使用方括号语法访问它的每一个元素（即第一个元素是 `arguments[0]`，第二个元素是`arguments[1]`，以此类推），使用 `length` 属性来确定传递进来多少个参数。

  > 可以在函数体内不显式地使用命名参数
  >
  > ```javascript
  > function sayHi(){
  > 	alert("Hello" + arguments[0] + "," + arguments[1]);
  > }
  > ```
  >
  > => 这个事实说明了ECMAScript函数的一个重要特点：命名的参数只提供便利，但不是必需的

- `arguments` 对象只是与数组类似（它并不是 `Array` 的实例）

- `arguments` 对象可以与*命名参数* 一起使用

- `arguments` 对象的值永远与对应*命名参数* 的值保持同步

  > 这并不是说读取这两个值会访问相同的内存空间；
  >
  > 它们的内存空间是独立的，但它们的值会同步。

!> **ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。**

> 访问变量有**按值**和**按引用**两种方式，而参数只能按值传递

## **函数声明**语法 VS **函数表达式**定义函数

  - 函数声明

```javascript
function sum (num1, num2) {
	return num1 + num2;
}
```

  - 函数表达式（匿名函数）【并非函数，实际为一个变量，只是其值为函数】

```javascript
var sum = function (num1, num2) { // 在使用函数表达式定义函数时，没有必要使用函数名，通过变量即可以引用函数；
	return num1 + num2;
}; // 还要注意函数末尾有一个分号，就像声明其他变量时一样
```

### 函数声明提升(function declaration hoisting)

**在向执行环境中加载数据时，*解析器* 会率先读取函数声明，并使其在执行任何代码之前可用**；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。

```javascript
alert (sum(10,10));

function sum(num1, num2) {
	return num1 + num2;
}
```
>
> 以上代码完全可以正常运行，是因为在代码开始执行之前，*解析器* 就已经通过一个名为**函数声明提升（function declaration hoisting）**的过程，读取并将函数声明添加到执行环境中。对代码求值时，*JavaScript引擎* 在第一遍会声明函数并将它们放到源代码树的顶部。

?> 除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。

## **函数实际上是对象**

- 每个函数都是 `Function` 类型的实例，而且都与其他引用类型一样具有属性和方法。
- 由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。

`Function` 构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体

```javascript
var sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
```

>从技术角度讲，这是一个函数表达式。但是，不推荐使用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。
>
>不过，这种语法对于理解**"函数是对象，函数名是指针"**的概念倒是非常直观的。
>
>p.s. 使用不带圆括号的函数名是访问函数指针，而非调用函数。