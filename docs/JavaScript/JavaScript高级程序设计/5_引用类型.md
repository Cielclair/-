# 第5章 引用类型

## 5.1 **Object**类型

## 5.2 **Array**类型

## 5.3 **Date**类型

## 5.4 **RegExp**类型

## 5.5 **Function**类型

**函数实际上是对象**

- 每个函数都是 `Function` 类型的实例，而且都与其他引用类型一样具有属性和方法。
- 由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。



#### 函数定义的语法

  - 函数声明

```javascript
function sum (num1, num2) {
	return num1 + num2;
}
```

  - 函数表达式（匿名函数）

    <details>
	<summary>Ciel按：</summary>
	
	实际为一个变量，只是其值为函数
	</details>

```javascript
var sum = function (num1, num2) { // 在使用函数表达式定义函数时，没有必要使用函数名，通过变量即可以引用函数；
	return num1 + num2;
}; // 还要注意函数末尾有一个分号，就像声明其他变量时一样
```

- `Function` 构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体

```javascript
var sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
```

>从技术角度讲，这是一个函数表达式。但是，不推荐使用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。
>
>不过，这种语法对于理解**"函数是对象，函数名是指针"**的概念倒是非常直观的。
>
>p.s. 使用不带圆括号的函数名是访问函数指针，而非调用函数。

### 5.5.2 **函数声明**与**函数表达式**

#### 函数声明提升(function declaration hoisting)

**在向执行环境中加载数据时，*解析器* 会率先读取函数声明，并使其在执行任何代码之前可用**；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。

```javascript
alert (sum(10,10));

function sum(num1, num2) {
	return num1 + num2;
}
```

>以上代码完全可以正常运行，是因为在代码开始执行之前，*解析器* 就已经通过一个名为**函数声明提升（function declaration hoisting）**的过程，读取并将函数声明添加到执行环境中。对代码求值时，*JavaScript引擎* 在第一遍会声明函数并将它们放到源代码树的顶部。

?> 除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。

### 5.5.3 作为值的函数

### 5.5.4 函数内部属性

### 5.5.5 函数属性和方法

## 5.6 基本包装类型

为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：

- Boolean
- Number
- String

这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。

我们知道，基本类型值不是对象，因而从逻辑上讲他们不应该有方法。

实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。

?> **引用类型**与**基本包装类型**的主要区别就是对象的生存期。

- 使用 `new` 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。

- 而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。

  > 这意味着我们不能在运行时为基本类型值添加属性和方法。

!> 使用 `new` 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。

```javascript
var value = "25";

var number = Number(value); // 转型函数
alert(typeof number); // "number"

var obj = new Number(value); // 构造函数
alert(typeof obj); // "object"
```

这个例子中，变量 `number` 中保存的是基本类型的值25，而变量 `obj` 中保存的是 `Number` 的实例。

### 5.6.1 **Boolean**类型

### 5.6.2 **Number**类型

### 5.6.3 **String**类型

## 5.7 单体内置对象

ECMA-262对内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”

> 意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。

### 5.7.1 Global对象

`Global` 对象可以说是ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript中的 `Global` 对象在某种意义上是作为一个终极的“兜底对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数：

?> 所有在全局作用域中定义的属性和函数，都是Global对象的属性。诸如 `isNaN()` 、`isFinite()` 、`parseInt()` 以及 `parseFloat()`，实际上全都是Global对象的方法。

除此之外，`Global` 对象还包含其他一些方法。

#### 1. URI编码方法

#### 2. `eval()` 方法

`eval()` 方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript字符串。

当解析器发现代码中调用 `eval()` 方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。

?> 在 `eval()` 中创建的任何变量或函数都不会被提升